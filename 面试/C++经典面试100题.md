## 100条经典C++语言笔试题目

题目类型

- C++与C差异(1-18)
- 数据类型、关键字(19-37)
- C++面向对象的特性(38-61)
- 程序阅读题(62-90)
- 编程练习(比C要难)(91-100)

### 1、C和C++中struct有什么区别？

| 区别   | Protection行为 | 能否定义函数     |
| ---- | ------------ | ---------- |
| C    | 无            | 否，但可以有函数指针 |
| C++  | 有，默认是public  | 可以         |

### 2、C++中的struct和class有什么区别？

从语法上讲，class和struct做类型定义时只有两点区别：

- 默认继承权限。如果不明确指定，来自class的继承按照private继承处理，来自struct的继承按照public继承处理；
- 成员的默认访问权限。class的成员默认是private权限，struct默认是public权限。
- 除了这两点，class和struct基本就是一个东西。语法上没有任何其它区别。

### 3、如何判断一段程序是由C 编译程序还是由C++编译程序编译的？

```C++
#ifdef __cplusplus
	cout<<"c++";
#else
	cout<<"c";
#endif
```

### 4、 C和C++有什么不同?

从机制上：c是面向过程的（但c也可以编写面向对象的程序）；c++是面向对象的，提供了类。但是，c++编写面向对象的程序比c容易。

从适用的方向：c适合要求代码体积小的，效率高的场合，如嵌入式、驱动；c++适合更上层的，复杂的，大型的; linux核心大部分是c写的，因为它是系统软件，效率要求极高。

从名称上也可以看出，c++比c多了+，说明c++是c的超集；那为什么不叫c+而叫c++呢，是因为c++比c来说扩充的东西太多了，所以就在c后面放上两个+；于是就成了c++。

C语言是结构化编程语言，C++是面向对象编程语言。 

C++侧重于对象而不是过程，侧重于类的设计而不是逻辑的设计。

### 5、“引用”与指针的区别是什么？

指针通过某个指针变量指向一个对象后，对它所指向的变量间接操作。程序中使用指针，程序的可读性差；而引用本身就是目标变量的别名，对引用的操作就是对目标变量的操作。

### 6. 虚函数

```C++
class A
{ 
	virtual void func1();
	void func2(); 
};

class B: class A 
{ 
	void func1()
	{
		cout < < "fun1 in class B" < < endl;
	}
    
	virtual void func2()
	{
		cout < < "fun2 in class B" < < endl;
	}
}
```

- A：A中的func1和B中的func2都是虚函数
- B：A中的func1和B中的func2都不是虚函数
- C：A中的func2是虚函数.，B中的func1不是虚函数
- D：A中的func2不是虚函数，B中的func1是虚函数

标准答案：A

### 7、int id[sizeof(unsigned long)];这个对吗？为什么？

【标准答案】正确。这个 sizeof是编译时运算符，编译时就确定了 可以看成和机器有关的常量。

### 8、某文件中定义的静态全局变量(或称静态外部变量)其作用域是 ( )?

- A.只限某个函数
- B.本文件
- C.跨文件 
- D.不限制作用域

B。静态全局变量则限制了其作用域， 即只在定义该变量的源文件内有效， 在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用， 因此可以避免在其它源文件中引起错误。

### 9、C++函数中值的传递方式有哪几种?

C++函数的三种传递方式为：值传递、指针传递和引用传递。

### 10、对于一个频繁使用的短小函数,在C语言中应用什么实现,在C++中应用什么实现?

c用宏定义，c++用inline 内联函数

### 11、引用与指针有什么区别？				 

1) 引用必须被初始化，指针不必。

2) 引用初始化以后不能被改变，但 C++ 11 引用可以改变；指针可以改变所指的对象。

3) 不存在指向空值的引用，但是存在指向空值的指针。

### 12、C++中virtual与inline的含义分别是什么？

在基类成员函数的声明前加上virtual关键字，意味着将该成员函数声明为虚函数。inline与函数的定义体放在一起，使该函数称为内联。inline是一种用于实现的关键字，而不是用于声明的关键字。

虚函数的特点；如果希望派生类能够重新定义基类的方法，则在基类中将该方法定义为虚方法，这样可以启用动态联编。

内联函数的特点；使用内联函数的目的是为了提高函数的运行效率。内联函数体的代码不能过长，因为内联函数省去调用函数的时间是以代码膨胀为代价的。内联函数不能包含循环语句，因为执行循环语句要比调用函数的开销大。

静态联编，动态联编（动态绑定，运行时决定）

### 13、VC中，编译工具条内的Debug与Release选项是什么含义？

Debug 通常称为调试版本，它包含调试信息，并且不作任何优化，便于程序员调试程序。Release 称为发布版本，它往往是进行了各种优化，使得程序在代码大小和运行速度上都是最优的，以便用户很好地使用。Debug带有大量的调试代码，运行时需要相应的运行库，发布模式程序紧凑不含有调试代码和信息，直接可以运行（如果不需要运行库）

### 14、函数assert的用法?

断言assert是仅在debug版本起作用的宏，用于检查“不应该“发生的情况。程序员可以把assert看成一个在任何系统状态下都可以安全使用的无害测试手段。

### 15、 const  与 #define 的比较 ，const有什么优点?

const 常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误（边际效应） 。

有些集成化的调试工具可以对 const 常量进行调试，但是不能对宏常量进行调试。

### 16、请你谈谈引用和指针的区别。

- 引用被创建的同时必须被初始化（指针则可以在任何时候被初始化）
- 不能有 NULL 引用，引用必须与合法的存储单元关联（指针则可以是 NULL） 
- 一旦引用被初始化，就不能改变引用的关系（指针则可以随时改变所指的对象） 
- 右值引用可以引用寄存器

### 17、有了 malloc/free 为什么还要 new/delete  ？

malloc 与 free 是 C++/C 语言的标准库函数，new/delete 是 C++的运算符。它们都可用于申请动态内存和释放内存。 对于非内部数据类型的对象而言，光用 malloc/free 无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于malloc/free 是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于 malloc/free。 因此 C++语言需要一个能完成动态内存分配和初始化工作的运算符 new，以及一个能完成清理与释放内存工作的运算符 delete。注意 new/delete 不是库函数。

### 18、如果在申请动态内存时找不到足够大的内存块，malloc 和 new 将返回 NULL 指针，宣告内存申请失败。你是怎么处理内存耗尽的？

- 判断指针是否为 NULL，如果是则马上用 return 语句终止本函数。
- 判断指针是否为 NULL，如果是则马上用 exit(1)终止整个程序的运行
- 为 new 和 malloc 设置异常处理函数。例如 Visual C++可以用_set_new_hander 函数为 new 设置用户自己定义的异常处理函数，也可以让 malloc 享用与 new 相同的异常处理函数。

### 19、C++是不是类型安全的？

不是。两个不同类型的指针之间可以强制转换（用reinterpret cast)。

### 20、 const 符号常量；

1. const char *p
2. char const *p
3. char * const p

说明上面三种描述的区别

- p是一个指向const char的指针，p是可以改变指向的，但是p指向的值是不能改变的;
- p指向的恰好是一个指向const的char的普通指针；
- p是一个指针，这个指针是指向char的const指针。1和2的定义是一样的。

### 21、用C++写个程序，如何判断一个操作系统是16位还是32位的？

定义一个指针p，打印出sizeof(p),如果节果是4，则表示该操作系统是32位，打印结果是2，表示是16位。

### 22、用C++写个程序，如何判断一个操作系统是16位还是32位的？不能用sizeof()函数。

```C++
int a = ~0; // 16位的int，最大值是65535
if( a>65536 ){
	cout<<"32 bit"<<endl;
}else{
	cout<<"16 bit"<<endl;
}
```

23、下面的代码分别表示什么意思？

```C++
void * ( * (*fp1)(int))[10];
```

fp1是一个指针，指向一个函数，这个函数的参数为int型，函数的返回值是一个指针，这个指针指向一个数组，这个数组有10个元素，每个元素是一个void*型指针。

```C++
float (*(* fp2)(int,int,int))(int);	 
// p = (* fp2)(int,int,int)
// ==> float (* p)(int)
```

fp2是一个指针，指向一个函数，这个函数的参数为3个int型，函数的返回值是一个指针，这个指针指向一个函数，这个函数的参数为int型，函数的返回值是float型。

```C++
int (* ( * fp3)())[10]();
// p = ( * fp3)()  函数指针
// ==> int (* p)[10]();
// 返回值是数组指针，数组的元素是函数指针
```

fp3是一个指针，指向一个函数，这个函数的参数为空，函数的返回值是一个指针，这个指针指向一个数组，这个数组有10个元素，每个元素是一个指针，指向一个函数，这个函数的参数为空，函数的返回值是int型。

### 24、多态类中的虚函数表是Compile-Time，还是Run-Time时建立的?

虚拟函数表是在编译期就建立了,各个虚拟函数这时被组织成了一个虚拟函数的入口地址的数组.而对象的隐藏成员--虚拟函数表指针是在运行期--也就是构造函数被调用时进行初始化的,这是实现多态的关键。

### 25 、错误的转义字符是 、错误的转义字符是 、错误的转义字符是 ()

- A. '\091' 			
- B. '\\'
   - C. '\0' 
- D. '\'

【标准答案 】A

### 26、若数组名作实参而指针变量作形参，函数调用实参传给形参的是 ()

A.数组的长度		B.数组第一个元素的值		C.数组所有元素的值	D.数组第一个元素的地址

【标准答案】D

### 27、变量的指针含意是指变量的 ()

A.值  	B.地址 	C.存储  	D.名字

【标准答案】B

### 28、内存的分配方式有几种?

从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量。

在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。

从堆上分配，亦称动态内存分配。程序在运行的时候用malloc或new申请任意多少的内存，程序员自己负责在何时用free或delete释放内存。动态内存的生存期由我们决定，使用非常灵活，但问题也最多。

### 29、float a,b,c ,问等式 `(a+b)+c==(b+a)+c 和(a+b)+c==(a+c)+b`能否成立？

两者都不行。在比较float或double时，不能简单地比较。由于计算误差，相等的概率很低。应判断两数之差是否落在区间（-e,e)内。这个e应比浮点数的精度大一个数量级。  

### 30、全局变量和局部变量有什么区别？是怎么实现的？操作系统和编译器是怎么知道的？ 

生命周期不同：全局变量随主程序创建和创建，随主程序销毁而销毁；局部变量在局部函数内部，甚至局部循环体等内部存在，退出就不存在； 内存中分配在全局数据区。 

使用方式不同：通过声明后全局变量程序的各个部分都可以用到；局部变量只能在局部使用；分配在栈区。  操作系统和编译器通过内存分配的位置来知道的，全局变量分配在全局数据段并且在程序开始运行的时候被加载。局部变量则分配在堆栈里面 。

### 31、Heap与stack的差别

- Heap是堆，stack是栈。
- Stack的空间由操作系统自动分配/释放，Heap上的空间手动分配/释放。
- Stack空间有限，Heap是很大的自由存储区C中的malloc函数分配的内存空间即在堆上,C++中对应的是new操作符。
- 程序在编译期对变量和函数分配内存都在栈上进行,且程序运行过程中函数调用时参数的传递也在栈上进行


### 37、 const关键字？有哪些作用

const关键字至少有下列n个作用：

- 欲阻止一个变量被改变，可以使用const关键字。在定义该const变量时，通常需要对它进行初始化，因为以后就没有机会再去改变它了；
- 对指针来说，可以指定指针本身为const，也可以指定指针所指的数据为const，或二者同时指定为const；
- 在一个函数声明中，const可以修饰形参，表明它是一个输入参数，在函数内部不能改变其值；
- 对于类的成员函数，若指定其为const类型，则表明其是一个常函数，不能修改类的成员变量；
- 对于类的成员函数，有时候必须指定其返回值为const类型，以使得其返回值不为“左值”；
- C语言中的const是个冒牌货，const常量是个伪常量，可以通过指针间接修改；C++的const常量，存储在符号表中，是真常量

剖析：这个题可以考查面试者对程序设计知识的掌握程度是初级、中级还是比较深入，没有一定的知识广度和深度，不可能对这个问题给出全面的解答。大多数人只能回答出static和const关键字的部分功能。

### 76、以下三条输出语句分别输出什么？

```C++
char str1[]       = "abc";
char str2[]       = "abc";
const char str3[] = "abc"; 
const char str4[] = "abc"; 
const char* str5  = "abc";
const char* str6  = "abc";
cout << boolalpha << ( str1==str2 ) << endl; // 输出什么？ false
cout << boolalpha << ( str3==str4 ) << endl; // 输出什么？ false
cout << boolalpha << ( str5==str6 ) << endl; // 输出什么？ true
```

分别输出false,false,true。str1和str2都是字符数组，每个都有其自己的存储区，它们的值则是各存储区首地址，不等；str3和str4同上，只是按const语义，它们所指向的数据区不能修改。str5和str6并非数组而是字符指针，并不分配存储区，其后的“abc”以常量形式存于静态数据区，而它们自己仅是指向该区首地址的指针，相等。